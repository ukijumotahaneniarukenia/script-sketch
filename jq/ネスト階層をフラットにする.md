# デフォルト

IN
```
cat l.json | jq
```
OUT
```
{
  "a": "foo",
  "b": {
    "c": {
      "d": {
        "test": {
          "key": "value"
        }
      }
    }
  }
}
```
# コンパクト出力かつフラット化
IN
```
cat l.json | jq --stream -c ''
```
OUT
```
[["a"],"foo"]
[["b","c","d","test","key"],"value"]
[["b","c","d","test","key"]]
[["b","c","d","test"]]
[["b","c","d"]]
[["b","c"]]
[["b"]]
```
# 要素確認

配列要素数が2のものが一意のKeyに紐づくValueをもつもの
IN
```
cat l.json | jq --stream -c 'length'
```
OUT
```
2
2
1
1
1
1
1
```

# 2以外を除去

第一要素にカンマ区切りで持ち回ってくれているからしぼってOK

IN
```
cat l.json | jq --stream -c 'select(length==2)'
```

OUT
```
[["a"],"foo"]
[["b","c","d","test","key"],"value"]
```



# 第一要素をドット区切りに整形してjsonオブジェクトを生成

```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}'
{"key":"a","value":"foo"}
{"key":"b.c.d.test.key","value":"value"}
```


# slurpする前
IN
```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}' | jq ''
```
OUT
```
{
  "key": "a",
  "value": "foo"
}
{
  "key": "b.c.d.test.key",
  "value": "value"
}
```
# slurpする後

配列にくるんでくれる

IN
```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}' | jq -s ''
```
ロングオプションだとこう

IN
```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}' | jq --slurp ''
```

OUT
```
[
  {
    "key": "a",
    "value": "foo"
  },
  {
    "key": "b.c.d.test.key",
    "value": "value"
  }
]
```

#複数オブジェクトを単一オブジェクトに変換

from_entriesでいける
IN
```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}' | jq -s 'from_entries'
```
OUT
```
{
  "a": "foo",
  "b.c.d.test.key": "value"
}
```


# fzfで絞れる

はじめてしった


単一ないし、複数オブジェクトをパイプで流してオブジェクトを矢印で選択し、プロンプトに検索単語を入力し、Enterすると標準出力に出力される

- https://qiita.com/arc279/items/e328e97032c962a6947e

```
cat l.json | jq --stream -c 'select(length==2)|{key:.[0]|join("."),value:.[1]}' | fzf
```
